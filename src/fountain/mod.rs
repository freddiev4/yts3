use thiserror::Error;

#[derive(Error, Debug)]
pub enum FountainError {
    #[error("encoding failed: {0}")]
    Encode(String),
    #[error("decoding failed: {0}")]
    Decode(String),
    #[error("not enough symbols received: have {received}, need {needed}")]
    InsufficientSymbols { received: usize, needed: usize },
}

/// A single encoded symbol with its encoding symbol ID.
#[derive(Debug, Clone)]
pub struct EncodedSymbol {
    pub esi: u32, // Encoding Symbol ID
    pub data: Vec<u8>,
    pub is_repair: bool,
}

/// Encode a data chunk into source + repair symbols using a simple XOR-based fountain code.
///
/// This is a lightweight fountain code implementation:
/// - Source symbols are the original data split into symbol_size pieces
/// - Repair symbols are generated by XOR-combining pairs/triples of source symbols
/// - This provides redundancy that allows recovery from some symbol loss
pub fn encode_chunk(
    chunk_data: &[u8],
    symbol_size: usize,
    repair_overhead: f64,
) -> Result<Vec<EncodedSymbol>, FountainError> {
    if chunk_data.is_empty() {
        return Ok(vec![EncodedSymbol {
            esi: 0,
            data: vec![0u8; symbol_size],
            is_repair: false,
        }]);
    }

    // Pad the chunk to a multiple of symbol_size
    let padded_len = ((chunk_data.len() + symbol_size - 1) / symbol_size) * symbol_size;
    let mut padded = vec![0u8; padded_len];
    padded[..chunk_data.len()].copy_from_slice(chunk_data);

    let k = padded_len / symbol_size; // Number of source symbols
    let num_repair = ((k as f64) * repair_overhead).ceil() as usize;

    let mut symbols = Vec::with_capacity(k + num_repair);

    // Source symbols
    for i in 0..k {
        let start = i * symbol_size;
        let end = start + symbol_size;
        symbols.push(EncodedSymbol {
            esi: i as u32,
            data: padded[start..end].to_vec(),
            is_repair: false,
        });
    }

    // Repair symbols via deterministic XOR combinations
    for r in 0..num_repair {
        let mut repair = vec![0u8; symbol_size];

        // Use a simple deterministic pattern: each repair symbol XORs a subset of source symbols.
        // The pattern is determined by the repair index to ensure diversity.
        let seed = r as u32;
        let num_sources_to_combine = 2 + (seed % 3) as usize; // combine 2-4 source symbols

        for j in 0..num_sources_to_combine {
            let src_idx = ((seed.wrapping_mul(2654435761)
                .wrapping_add((j as u32).wrapping_mul(2246822519)))
                % k as u32) as usize;
            let src = &symbols[src_idx].data;
            for (rb, sb) in repair.iter_mut().zip(src.iter()) {
                *rb ^= *sb;
            }
        }

        symbols.push(EncodedSymbol {
            esi: (k + r) as u32,
            data: repair,
            is_repair: true,
        });
    }

    Ok(symbols)
}

/// State for decoding a single chunk from received symbols.
pub struct ChunkDecoder {
    k: usize, // number of source symbols needed
    symbol_size: usize,
    source_symbols: Vec<Option<Vec<u8>>>,
    repair_symbols: Vec<(u32, Vec<u8>)>,
    received_source_count: usize,
}

impl ChunkDecoder {
    pub fn new(k: usize, symbol_size: usize) -> Self {
        Self {
            k,
            symbol_size,
            source_symbols: vec![None; k],
            repair_symbols: Vec::new(),
            received_source_count: 0,
        }
    }

    /// Feed a received symbol to the decoder.
    pub fn add_symbol(&mut self, esi: u32, data: Vec<u8>, is_repair: bool) {
        if is_repair {
            self.repair_symbols.push((esi, data));
        } else {
            let idx = esi as usize;
            if idx < self.k && self.source_symbols[idx].is_none() {
                self.source_symbols[idx] = Some(data);
                self.received_source_count += 1;
            }
        }
    }

    /// Check if we have all source symbols (direct recovery).
    pub fn is_complete(&self) -> bool {
        self.received_source_count == self.k
    }

    /// Attempt to recover the original chunk data.
    pub fn recover(&self, original_size: usize) -> Result<Vec<u8>, FountainError> {
        if !self.is_complete() {
            // Try to recover missing symbols using repair symbols.
            // For our XOR-based scheme, if only one source symbol is missing
            // from a repair group, we can recover it.
            let mut symbols = self.source_symbols.clone();
            let mut recovered_count = self.received_source_count;

            // Iteratively try to recover missing symbols
            let mut made_progress = true;
            while made_progress && recovered_count < self.k {
                made_progress = false;
                for (esi, repair_data) in &self.repair_symbols {
                    let r = (*esi as usize).saturating_sub(self.k);
                    let seed = r as u32;
                    let num_sources = 2 + (seed % 3) as usize;

                    // Find which source symbols this repair combines
                    let mut source_indices = Vec::with_capacity(num_sources);
                    for j in 0..num_sources {
                        let src_idx = ((seed.wrapping_mul(2654435761)
                            .wrapping_add((j as u32).wrapping_mul(2246822519)))
                            % self.k as u32) as usize;
                        source_indices.push(src_idx);
                    }

                    // Check if exactly one source is missing
                    let missing: Vec<usize> = source_indices
                        .iter()
                        .filter(|&&idx| symbols[idx].is_none())
                        .copied()
                        .collect();

                    if missing.len() == 1 {
                        let missing_idx = missing[0];
                        let mut recovered = repair_data.clone();
                        for &idx in &source_indices {
                            if idx != missing_idx {
                                if let Some(ref src) = symbols[idx] {
                                    for (rb, sb) in recovered.iter_mut().zip(src.iter()) {
                                        *rb ^= *sb;
                                    }
                                }
                            }
                        }
                        symbols[missing_idx] = Some(recovered);
                        recovered_count += 1;
                        made_progress = true;
                    }
                }
            }

            if recovered_count < self.k {
                return Err(FountainError::InsufficientSymbols {
                    received: recovered_count,
                    needed: self.k,
                });
            }

            // Reassemble from recovered symbols
            let mut result = Vec::with_capacity(self.k * self.symbol_size);
            for sym in &symbols {
                result.extend_from_slice(sym.as_ref().unwrap());
            }
            result.truncate(original_size);
            return Ok(result);
        }

        // All source symbols present: reassemble directly
        let mut result = Vec::with_capacity(self.k * self.symbol_size);
        for sym in &self.source_symbols {
            result.extend_from_slice(sym.as_ref().unwrap());
        }
        result.truncate(original_size);
        Ok(result)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_encode_decode_roundtrip() {
        let data = b"Hello, this is test data for fountain codes!";
        let symbol_size = 8;

        let symbols = encode_chunk(data, symbol_size, 1.0).unwrap();
        let k = (data.len() + symbol_size - 1) / symbol_size;

        let mut decoder = ChunkDecoder::new(k, symbol_size);
        for sym in &symbols {
            if !sym.is_repair {
                decoder.add_symbol(sym.esi, sym.data.clone(), false);
            }
        }
        assert!(decoder.is_complete());

        let recovered = decoder.recover(data.len()).unwrap();
        assert_eq!(&recovered, data.as_slice());
    }

    #[test]
    fn test_encode_decode_with_loss() {
        let data: Vec<u8> = (0..64).collect();
        let symbol_size = 8;

        let symbols = encode_chunk(&data, symbol_size, 1.0).unwrap();
        let k = (data.len() + symbol_size - 1) / symbol_size; // 8

        // Feed all repair symbols and all but one source symbol
        let mut decoder = ChunkDecoder::new(k, symbol_size);
        for sym in &symbols {
            if sym.is_repair {
                decoder.add_symbol(sym.esi, sym.data.clone(), true);
            } else if sym.esi != 0 {
                // Skip source symbol 0
                decoder.add_symbol(sym.esi, sym.data.clone(), false);
            }
        }

        assert!(!decoder.is_complete());
        let recovered = decoder.recover(data.len()).unwrap();
        assert_eq!(recovered, data);
    }

    #[test]
    fn test_encode_empty() {
        let symbols = encode_chunk(&[], 256, 1.0).unwrap();
        assert_eq!(symbols.len(), 1);
    }
}
